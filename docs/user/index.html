<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="User"><title>user - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-80aa586b.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="user" data-themes="" data-resource-suffix="" data-rustdoc-version="1.94.0-nightly (21cf7fb3f 2025-12-28)" data-channel="nightly" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-7bab91a1.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-ffcac47a.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate user</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../user/index.html">user</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#user" title="User">User</a><ul><li><a href="#dropping" title="Dropping">Dropping</a></li><li><a href="#thread-safety" title="Thread Safety">Thread Safety</a></li></ul></li></ul><h3><a href="#macros">Crate Items</a></h3><ul class="block"><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#statics" title="Statics">Statics</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>user</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/user/lib.rs.html#1-265">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="user"><a class="doc-anchor" href="#user">§</a>User</h2>
<p>This crate is for management of the Real and Effective Users of a SetUID program. On non-SetUID programs, all functions in this crate are no-ops. Management is controlled via the <code>Mode</code> enum, which contains the following values:</p>
<ul>
<li><code>Real</code> mandates the Real User, or the user launching the process.</li>
<li><code>Effective</code> mandates the Effective User, or the user that owns the program.</li>
<li><code>Original</code> mandates the Operating Mode the program was launched with</li>
<li><code>Existing</code> mandates whatever Mode is currently in use.</li>
</ul>
<p>These values can be directly queried via the <code>USER</code> and <code>GROUP</code> static values.</p>
<p>You can interact with these modes with the following functions:</p>
<ul>
<li><code>set()</code> will set the Operating Mode to the one selected, and return what the Mode was prior to the call.</li>
<li><code>current()</code> returns the current Operating Mode.</li>
<li><code>revert()</code> will set the Operating Mode to <code>Original</code></li>
<li><code>restore() </code>will return the Operating Mode to the value returned by <code>set()</code>.</li>
</ul>
<h3 id="dropping"><a class="doc-anchor" href="#dropping">§</a>Dropping</h3>
<p><code>drop()</code> differs from the above operations in that it destructively sets the Saved UID to the desired mode as well. This means that the program will be unable to return to the dropped mode (IE Calling <code>drop(Real)</code> will prevent you from ever returning to Effective, and vice versa.</p>
<p>This is useful in <code>fork+exec</code> semantics, where the child can have its privileges dropped to the desired User, rather than allowing it to continue running under the dual SetUID mode of the parent.</p>
<h3 id="thread-safety"><a class="doc-anchor" href="#thread-safety">§</a>Thread Safety</h3>
<p>None of the above functions are thread-safe. If you have multiple threads that are all changing the current Operating Mode, it is entirely possible that the code between a <code>set</code> and <code>restore</code> call can change from the desired Mode, causing unpredictable and erroneous behavior. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>worker(name: <span class="kw-2">&amp;</span>str) {
	<span class="kw">let _ </span>= <span class="macro">user::as_effective!</span>({
		std::fs::File::create(<span class="macro">format!</span>(<span class="string">"/tmp/{name}"</span>));
		std::fs::remove_file(<span class="macro">format!</span>(<span class="string">"/tmp/{name}"</span>));
	});
}

<span class="kw">for </span>name <span class="kw">in </span>[<span class="string">"t1"</span>, <span class="string">"t2"</span>, <span class="string">"t3"</span>] {
	std::thread::spawn(|| worker(name));
}

user::set(user::Mode::Real);
std::fs::File::create(<span class="string">"/tmp/parent"</span>);
std::fs::remove_file(<span class="string">"/tmp/parent"</span>);</code></pre></div>
<p>There is no guarantee that the parent’s call to <code>File::create</code> will run as the Real User, as the detached threads may have changed the mode between <code>set</code> and <code>create</code>. Additionally, the file may not be removed as the Real user for the same reason, which could cause a Permission Error.</p>
<p>For these kinds of situations, the <code>run_as</code> macro (And the <code>as_effective</code> and <code>as_real</code> wrappers) is required. They utilized a Synchronization Singleton to ensure that only a single thread using these functions can set the user mode at any one time. When the macro finishes, the Singleton is dropped, and another thread can acquire it to change modes. If you don’t need the added overhead of synchronization, such as in single threaded environments, or where you set the mode in the parent before spawning the threads, you can safely use the functions directly.</p>
<p>A safe implementation of the above the example would be:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>worker(name: <span class="kw-2">&amp;</span>str) {
	<span class="kw">let _ </span>= <span class="macro">user::as_effective!</span>({
		std::fs::File::create(<span class="macro">format!</span>(<span class="string">"/tmp/{name}"</span>));
		std::fs::remove_file(<span class="macro">format!</span>(<span class="string">"/tmp/{name}"</span>));
	});
}

<span class="kw">for </span>name <span class="kw">in </span>[<span class="string">"t1"</span>, <span class="string">"t2"</span>, <span class="string">"t3"</span>] {
	std::thread::spawn(|| worker(name));
}

<span class="macro">user::as_real!</span>({
	std::fs::File::create(<span class="string">"/tmp/parent"</span>);
	std::fs::remove_file(<span class="string">"/tmp/parent"</span>);
});</code></pre></div></div></details><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.as_effective.html" title="macro user::as_effective">as_<wbr>effective</a></dt><dd>Run the block/expression as the Effective User. This is thread safe.</dd><dt><a class="macro" href="macro.as_real.html" title="macro user::as_real">as_real</a></dt><dd>Run the block/expression as the Real User. This is thread safe.</dd><dt><a class="macro" href="macro.run_as.html" title="macro user::run_as">run_as</a></dt><dd>This is a thread-safe wrapper that sets the mode, runs the closure/expression,
then returns to the mode before the call. You can use this in multi-threaded
environments, and it is guaranteed the content of the closure/expression will
be run under the requested Mode.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Error.html" title="struct user::Error">Error</a></dt><dd>An error when trying to change UID/GID.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Mode.html" title="enum user::Mode">Mode</a></dt><dd>A SetUID mode.</dd></dl><h2 id="statics" class="section-header">Statics<a href="#statics" class="anchor">§</a></h2><dl class="item-table"><dt><a class="static" href="static.GROUP.html" title="static user::GROUP">GROUP</a></dt><dd>The Real, Effective, and Saved GID of the application.</dd><dt><a class="static" href="static.SETUID.html" title="static user::SETUID">SETUID</a></dt><dd>Whether the system is actually running under SetUid. If false, all functions here
are no-ops.</dd><dt><a class="static" href="static.USER.html" title="static user::USER">USER</a></dt><dd>The Real, Effective, and Saved UID of the application.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.current.html" title="fn user::current">current</a></dt><dd>Get the current user mode
Note that this is not thread-safe, and your program can suffer
from TOC-TOU problems if you assume this value will remain the same
when you actually need to perform a privileged operation in a multi-threaded
environment.</dd><dt><a class="fn" href="fn.drop.html" title="fn user::drop">drop</a></dt><dd>Destructively change mode, preventing the process from returning.
This function will set Real, Effective, and Saved values to the
desired Mode. This prevents the process from changing their mode</dd><dt><a class="fn" href="fn.obtain_lock.html" title="fn user::obtain_lock">obtain_<wbr>lock</a></dt><dt><a class="fn" href="fn.restore.html" title="fn user::restore">restore</a></dt><dd>Restore a saved Uid/Gid combination
This function fails if the syscall does.</dd><dt><a class="fn" href="fn.revert.html" title="fn user::revert">revert</a></dt><dd>Revert the Mode to the original.
This function returns to the values of <code>USER</code> and <code>GROUP</code>.
This function can fail if the underlying syscall does.</dd><dt><a class="fn" href="fn.set.html" title="fn user::set">set</a></dt><dd>Set the Mode.
This function can never be misused to lock out the process
from returning to the original, or any other mode.
This function returns an error if the mode could not be
changed. Otherwise, it returns the old mode for use in
<code>restore()</code>.</dd></dl></section></div></main></body></html>