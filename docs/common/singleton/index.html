<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This file implements a Reentrant Synchronization Singleton, which is used to guard a critical path such that only a single thread may execute it at a time. The general use is:"><title>common::singleton - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-2eb46af5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="common" data-themes="" data-resource-suffix="" data-rustdoc-version="1.94.0-nightly (fecb335cb 2026-01-07)" data-channel="nightly" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-7bab91a1.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-ffcac47a.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module singleton</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../common/index.html">common</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module singleton</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate common</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">common</a></div><h1>Module <span>singleton</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/common/singleton.rs.html#1-109">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This file implements a Reentrant Synchronization Singleton, which is used to guard
a critical path such that only a single thread may execute it at a time. The
general use is:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Take control of the Singleton. This is a blocking operation.
</span><span class="kw">let </span>lock = common::singleton::Singleton::new();
<span class="comment">// ...
</span><span class="kw">if let </span><span class="prelude-val">Some</span>(lock) = lock {
    drop(lock)
}</code></pre></div>
<p>The primitive is Reentrant, meaning that once a thread owns the object, subsequent
calls do not cause recursive deadlock. The intializer will simply return None,
and the original MutexGuard acquired by the thread further up the call-stack
will remain. This means that if you have multiple critical paths which may
overlap, you do not need to worry about causing deadlock–the Singleton will
remain owned by the thread for the scope highest in the call-chain:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>critical_write() {
    <span class="comment">// Acquire a lock
    </span><span class="kw">let </span>_lock = common::singleton::Singleton::new();
    <span class="macro">println!</span>(<span class="string">"Rust already ensures only a single thread can write here, but we're being safe ;)"</span>);

    <span class="comment">// Because we already have the Singleton in this thread, this instance will be none. The MutexGuard
    // is held by the parent.
    </span><span class="macro">assert!</span>(_lock.is_none())
}

<span class="comment">// Acquire a lock for our critical section.
</span><span class="kw">let </span>_lock = common::singleton::Singleton::new();
<span class="kw">let </span>x = <span class="number">1</span>;

<span class="comment">// Write. Though we already hold an instance of the Singleton, we can safely call this from this thread.
</span>critical_write();

<span class="comment">// The lock will drop here, allowing the entire critical path to execute without multiple acquisitions.</span></code></pre></div></div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Singleton.html" title="struct common::singleton::Singleton">Singleton</a></dt><dd>The Singleton is a Reentrant Synchronization Type that can only be held by a single thread.</dd></dl></section></div></main></body></html>