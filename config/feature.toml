# Features define system resources required for a specific function. This can include, say,
# inclusion and setup of a specific library to use in the sandbox (IE hardened-malloc), to
# support for entire graphics toolkits (IE qt6).

# Every feature needs a name. This must be the same as the file name.
name = "feature"

# The description outlines what the feature is for. This is mandatory. Everything besides
# the name and description are optional
description = ""

# The conditional is an optional shell-command that must return 0 for the feature to be included.
# This can be used to ensure a optional resource is installed on the system.
# conditional = ""

# The caveat is any warning that should be displayed when a profile uses this feature. This could
# include anything from performance consideration (hardened_malloc), attack surface increases (lib),
# etc.
# caveat = ""

# Requires is a list of other features this feature depends on. Dependency resolution is
# recursive.
# requires = []

# Conflicts are features that cannot co-exist with this feature. A conflict blacklists
# a feature from the profile, regardless of how many other features depend on it, or
# even if the profile itself calls for it. This can, therefore, cause sandboxes to break
# if a required feature is conflicts and is removed.
# conflicts = []

# Additional binaries to pass to the sandbox.You can provide HOST=DEST semantics.
# binaries = []

# Additional libraries to pass to the sandbox. There are three different formats:
#   1.  Absolute paths to pointing to files: "/usr/lib/mylib.so"
#   2.  Directories, to which all contents will be resolved: "/usr/lib/mylib"
#   3.  Wildcards, which can match files or directories, and
#       localize at /usr/lib unless a path is provided: "/usr/lib/mylib*" or "mylib*"
# libraries = []

# Devices to pass, such as /dev/dri
# devices = []

# A list of arguments to pass to the sandbox before adding the main application. This can be used
# to add arguments to Bubblewrap directly, or to install a wrapper (Such as zypak). There are special
# values, as well:
#
# "#" Delineates the start of the sandbox_args. In essence, if the args starts with a "#", then it
# effectively means that it is taking exclusive control of the arguments. It guarantees to be put first,
# and all other arguments are truncated.
#
# "!" Delineates the end of the sandbox_arg. This is used in coordination with "#" for a feature/profile
# to ensure exclusive access to the sandbox arguments. If two #'s are detected, the sandbox bails.
#
# Because your order is not guaranteed, this presents two ways of using this argument:
# 1.  Cooperatively. You expect to be placed on the command line, but do not prioritize it. For example,
#     Zypak only has the wrapper.
# 2.  Exclusively. You use both # and ! to ensure only your arguments are passed. Debug-Shell and Stats
#     does this, as it changed how the sandbox behaves.
# sandbox_args = []

# IPC is mediated via xdg-dbus-proxy, allowing selective communication--particularly for Portals. For more
# information, see xdg-dbus-proxy's manual page.
# [ipc]
#
# This setting overrules everything else in this section, and unconditionally disables all
# IPC. No proxy is run, no access to the User/System bus is provided. This is useful to
# pass on the command line if you need to temporarily disable Portals--say to open a file
# exposed in the sandbox itself, and not one from the host.
#
# Note that for Features, you can set disable to false and guarantee it will be set to false.
# Other features and profiles will not interfere with this flag if you've set it to false.
# disable = false
#
# If you need unrestricted access to the user bus, this mounts it directly into the sandbox. However, unless
# your application explicitly requires this permission (Such as DBus Monitors like Bustle), you should use
# the more fine-grained controls below. Setting this option disregards those aforementioned settings, as the
# proxy is not run.
#
# In the same fashion as above, you can guarantee that setting this to true will reflect in
# the end sandbox. Features can only set to true if the value is unset.
# user_bus = false
#
# If you want to expose the system bus to the program, you can do so here; this is likely not necessary. There
# is not way to filter the system bus. You either pass it entirely, or you don't (And you almost definitely
# don't need to unless your application talks to privileged busses, like virt-manager).
#
# In the same fashion as above, you can guarantee that setting this to true will reflect in
# the end sandbox. Features can only set to true if the value is unset.
# system_bus = false
#
# Portals are used primarily by Flatpak to provide functionality within a sandbox, use as Background to
# run in the background, Camera for the camera, FileChooser to provide arbitrary files, OpenURI to
# open files with the default handler, and more.
# portals = []
#
# See are busses that the application can see, but cannot interact with.
# see = []
#
# Talk are busses the application can talk over.
# talk = []
#
# Own are busses the application owns, particularly for GTK applications
# own = []
#
# Call are formatted as BUS=METHOD@PATH. If you don't know what that means, you don't need it.
# call = []

# Files specify various user, system, and direct files to be provided to the sandbox. Libraries and binaries
# do not fall into this group. Each group specifies three kinds of files:
#   1. ReadOnly provides files ro
#   2. ReadWrite provides files rw (Note files are mounted, so applications cannot replace them via move)
#   3. Executable provides files with chmod 555.
#
# By default, files are canonicalized to either the sandbox home or root, and match the path on the host
# (With the exception of translating /home/$USER to /home/antimony), but you can manually override this
# by specifying HOST=DEST, such as /etc/passwd=/etc/passwd.host if you want to place a file in an arbitrary
# location within the sandbox.
#
# [files]
#
# Passthrough defines how files that are given via the command line should be provided. This is used,
# for example, if you've integrated the sandbox, and are opening a supported file via your file explorer.
# passthrough = "ReadOnly"
# passthrough = "ReadWrite"
# passthrough = "Executable"
#
# User files have a root at the sandboxes home (~), so /.zshrc would point to ~/.zshrc, unless they have
# been qualified with absolute paths, such as /home/a/file, or $XDG_DATA_HOME/file.
# [files.user]
# ReadOnly = []
# ReadWrite = []
# Executable = []
#
# System files have the normal root as canonical (/).
# [files.platform]
# ReadOnly = []
# ReadWrite = []
# Executable = []
#
# [files.resources]
# ReadOnly = []
# ReadWrite = []
# Executable = []
#
# Direct files are constructed with the sandbox, creating the file with the path specified with the key,
# and the contents as the value. They are mounted ro.
# [files.direct]
# [files.direct.ReadOnly]
# "/my/file.txt" = "Contents"
#
# [files.direct.ReadWrite]
# "/my/file.txt.rw" = "Contents"
#
# [files.direct.Executable]
# "/my/file.txt.exe" = "#!/bin/bash"

# Keypair environment variables to pass to the sandbox.
# [environment]
# KEY = "VAL"

# Hooks are external commands that are run before/during/after the sandbox. They can be
# used to run dependencies, setup the environment, and perform additional cleanup.
#
# A warning for hooks defined in features: While you can guarantee that the hooks defined
# here will run in the order they are defined, and will run one after the other, you have
# no guarantee on how they will run in relation to other features. So, if you have hooks A,B,C defined
# in a feature, and D,E,F defined in another feature, Antimony will either run A,B,C,D,E,F or D,E,F,A,B,C.
# That is to say: DON'T RELY ON OTHER FEATURE'S HOOK RUNNING BEFORE/AFTER YOURS.
# Additionally, be incredibly careful about the parent hook. Just as you cannot guarantee when other features
# are imported in respect to yours, you cannot guarantee whether another feature's parent hook overwrites yours.
# That is to say: DON'T DEFINE PARENT HOOKS IN FEATURES UNLESS YOU ABSOLUTELY HAVE TO. EVEN THEN, RECONSIDER. IF
# YOU MUST, YOU MUST SET conflicts TO EVERY FEATURE THAT DOES THE SAME.
# [hooks]
#
# A pre-hook is run before the sandbox starts.
# [[pre]]
#
# An explicit path to a binary to execute. This is run
# under the regular user.
# path = "/path/to/script"
#
# The contents of a shell script to execute instead of a
# path. This is interpreted by bash as the regular user.
# If a hook defines both path and content, the path is
# used.
# content = "echo 'Hello, world!'"
#
# Arguments for the hook executable
# args = []
#
# Whether to attach the pre-hook to the sandbox.
# By default, Antimony will wait until all
# pre-hooks have executed before running the sandbox.
# If attach is set to true, the sandbox will run
# alongside the hook.
# attach = false
#
# By default, the hook does not get provided the
# environment (Such as PATH, HOME, etc). Regardless
# of this setting, the hook is provided the following:
#   1. ANTIMONY_NAME: The name of the profile
#   2. ANTIMONY_CACHE: The directory to the SOF
#   3. ANTIMONY_HOME: The path to the home, if it exists.
# env = false
#
# By default, a failed hook will abort sandbox startup.
# can_fail = false
#
# Post hooks run after the sandbox has finished, but before
# Antimony performs its own cleanup. Syntactically, they are
# identical to pre-hooks, but cannot be attached for obvious
# reasons.
# [[post]]
# path = "/path/to/hook"
# content = "echo 'Hello, world!'"
# args = []
# env = false
# can_fail = false
#
# The parent hook (Notice, this is a single value, not a list),
# is a specialized Pre-Hook that takes ownership of the sandbox.
# It operates identically to an attach-pre-hook, but with the change
# that when the parent dies, the sandbox does. If the sandbox dies,
# the parent remains alive. Contrast with a regular pre-hook, and
# when an attached hook dies, the sandbox remains, whereas the sandbox
# dying tears the hooks down with it.
#
# You can only have a single parent hook defined for a profile.
# [parent]
# path = "/path/to/hook"
# content = "echo 'Hello, world'"
# args = []
# env = false
# can_fail
